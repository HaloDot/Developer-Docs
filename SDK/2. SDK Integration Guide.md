# SDK Mobile Integration Guide #

This README provides technical guidance on the integration of the Halo SDK with a host Android application.

## Contents ##
1. Remote Attestation of Application by Halo Server
2. Requirements on the Mobile Back-End
3. SDK Binary
4. Application Manifest
5. Life-Cycle Methods
6. Initialization of the SDK
7. Transaction Flow

## 1. Remote Attestation of Application by Halo Server ##

In accordance with prescribed security requirements, Halo server performs remote attestation of the application using the Google SafetyNet attestation framework.

Since Halo is an Android Application Resource (AAR), while the target of the SafetyNet attestation is the entire Android Package (APK), Halo server needs to beconfi gured with details of any new APK prior to release, otherwise that APK will fail remote attestation during SDK initilization, and not be usable to transact.

**APK Values Required by Halo Server for Remote Attestation**

The following attestation payload fi eld must be confi gured in the Halo server with each release, so that they can be checked by the server during remote attestation.

field | description
----- | -----------
apkPackageName | fully qualifi ed APK name, e.g. za.co.synthesis.halo.halo_mpos_new
apkCertificateDigestSha256 | base64 encoded, SHA-256 hash of the certifi cate used to sign requesting app
applicationVersion | version number of application of host application


## 2. Requirements on the Mobile Back-End ##

**JWT**

All calls made to the Halo SDK requires a valid JWT. The mobile application server is expected to supply the mobile app with a JWT that can be used to authenticate with the Halo Kernel Server. The SDK requires acallback function, `onRequestJWT(callback: (String) -> Unit)`, that it will use whenever a JWT is required.

An asymmetric key is used so that the JWT can be issued (signed) by one system (mobile application server), and independantly verified by another (Halo server).

**JWT LifeTime**

Since the JWT essentially authorizes payment acceptance for a given merchant user, it is essential that the JWT lifetime be kept as short as possible, in order to limitthe amount of time an attacker has to crack the key itself, and then to limit the scope of damage in the event of a key compromise.

A lifetime of 15 minutes is recommended.

**JWT Signing Public Key Format**

The JWT public key should be published as a certifi cate, in in a text-friendly format, e.g. B64 encoded PEM (.crt, .pem).

**JWT Serialization Format**

The compact serialization format is expected, i.e:

```
urlencodedB64(header) + '.' + urlencodedB64(payload) + '.' + urlencodedB64(signature)
```

For example:

```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJsb2dnZWRJbkFzIjoiYWRtaW4iLCJpYXQiOjE0MjI3Nzk2Mzh9.gzSraSYS8EXBxLN_oWnFSRgCzcmJmMjLiuyu5CSpyH
```

**JWT Claims**

The JWT must make a number of claims - all of them standard except for aud_fingerprints (Audience Fingerprints):

| field | type | Note |
|:-----:|:----:|------|
alg | String | The signing algorithm is RSA signed SHA-256 hash, aliased as RS256. An asymmetric encryption(signing) scheme is required to allow the Kernel Server to be able to validate the token without being able to generate it. If symmetric key encryption was used to sign the auth token (e.g., using the HMAC algorithm), then non-repudiation would be lost. |
sub | String | The Payment Processor Merchant-User ID, or Application ID |
iss | String | This is a unique (from the perspective of Halo server) identifi er for the JWT issuer, agreed upon by the JWT issuer and Synthesis, and confi gured in advance bySynthesis in the Halo server, e.g. authserver.haloplus.io |
aud | String | URL of Halo server TLS endpoint, e.g. 'kernelserver.haloplus.io'. This value should be obtained from Synthesis (different per environment)|
usr | String | The details of the user performing the transaction, typically the username used to sign into the Integrators application. |
iat | NumericDate | The UTC timestamp of when the JWT was generated. |
exp | NumericDate | The UTC time of expiration of the JWT. |
halo_aud_fingerprints | String | a CSV list of expected SHA-256 fingerprints for the Kernel Server TLS endpoint. This list may contain multiple values to support certificate rotation. |

## 3. SDK Binary ##

HaloSDK is written in Kotlin, and packaged as an AAR (Android Archive Library). For security reasons, the compiled binary has been obfuscated.

See the [Getting Started Guide](1.%20Getting%20Started.md) for a detailed guide on accessing and getting started with the SDK.

## 4. Application Manifest ##

The `AndroidManifest.xml` application manifest file of the mobile application must include the following user permissions:
- `android.permission.INTERNET` - call out to the backend over the internet
- `android.permission.NFC`- use the NFC module

In addition, in order to indicate to the Play store that this is an NFC-enabled app, the `android.hardware.nfc` feature needs to be specifi ed, with `required=false` . If required is set to true then the mobile app itself will not be allowed to be installed on devices which don't support NFC, which is presumed to not be the desired behaviour.

**Android Gradle Plugin > 3.4.2**

Due to a limitation with the TEE library that is used, if the Android Gradle Plugin (`classpath 'com.android.tools.build:gradle'`) is greater than 3.4.2, the following attribute needs to be added to the application element inside the Android Manifest application 

```
android:extractNativeLibs="true"
```

## 5. Life-Cycle Methods ##

In order for the SDK to properly handle the Android application life cycle, the host app needs to add hooks into the following Android lifecycle methods on the `MAIN activity`.

:warning: **do not hook up to a SUB activity or a fragment** as this will cause problems

List of Android lifecycle methods:

- `onCreate(Bundle savedInstanceState)`
- `onStart()`
- `onResume()`
- `onPause()`
- `onStop()`
- `onSaveInstanceState(Bundle outState, PersistableBundle outPersistentState)`
- `onSaveInstanceState(Bundle outState)`
- `onDestroy()`

Halo SDK has corresponding static methods with matching method signatures for each of the Android lifecycle methods. 

This can all be wire up as follows:

```
public class MainActivity extends AppCompatActivity {
    @Override
    public void onCreate(Bundle savedInstanceState, PersistableBundle persistentState) {
        super.onCreate(savedInstanceState, persistentState);
        // your mobile app code here
        HaloSDK.onCreate(this , this, savedInstanceState, persistentState);
    }

    @Override
    protected void onStart() {
        super.onStart();
        // your mobile app code here
        HaloSDK.onStart();
    }

    @Override
    protected void onResume() {
        super.onResume();
        // your mobile app code here
        HaloSDK.onResume();
    }

    @Override
    protected void onPause() {
        super.onPause();
        // your mobile app code here
        HaloSDK.onPause();
    }

    @Override
    protected void onStop() {
        super.onStop();
        // your mobile app code here
        HaloSDK.onStop();
    }

    @Override
    public void onSaveInstanceState(@NonNull Bundle outState, @NonNull PersistableBundle outPersistentState) {
        super.onSaveInstanceState(outState, outPersistentState);
        // your mobile app code here
        HaloSDK.onSaveInstanceState(outState, outPersistentState);
    }

    @Override
    protected void onSaveInstanceState(@NonNull Bundle outState) {
        super.onSaveInstanceState(outState);
        // your mobile app code here
        HaloSDK.onSaveInstanceState(outState);
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        // your mobile app code here
        HaloSDK.onDestroy();
    }
}
```

## 6. Initialization of the SDK ##

Separate from the lifecycle hooks, the SDK must be initialized before transacting by calling the static `initialize` method on the SDK, passing it a `HaloInitializationParameters` object.

The SDK will attempt to perform the following sequence of actions:
- Perform runtime checks (device is not rooted, running in debug mode, or under instrumentation)
- Confirm that the software (Android version) and hardware platform (NFC device) is sufficient
- Connect to the server, passing on the JWT for verifi cation
- Confirm that the device has been enrolled, and is not blocked - re-enrolling if necessary
- Perform device-local Google SafetyNet key attestation actions, and submit results to the server for remote verification
- Retrieve terminal configuration from the server
- Initialize the SDK to a state where it will accept transactions

The result will be communicated, typically asynchronously (depending on exactly what happens and when), to the host application via invoking the callbackregistered in `IHaloCallbacks.onInitializationResult` and passing a `HaloInitializationResult`.

The `HaloInitializationResult.resultType` field indicates whether or not the initialization was successful or not. A value of `Initialized` indicates success, all other values indicate some kind of failure.

In the case of failure, the `errorCode` field may hold more information, whereas in the case of success, the SDK is now ready to accept a transaction.

**HaloInitializationParameters**

```
import za.co.synthesis.halo.sdk.model.HaloInitializationParameters

public class HaloInitializationParameters {
    public IHaloCallbacks haloCallBacks;
    public Long cardTimeTimeoutMS;
    public String applicationName;
    public String applicationVersion;
}
```

`Long cardTimeTimeoutMS` - Timeout value, in milliseconds, that the SDK will wait wait for a card tap after startTransaction has been called, before returning with a timeout error.

`String applicationName` - The fully qualified package name of the calling application.

`String applicationVersion` - The version number of the calling application.

`IHaloCallbacks haloCallBacks` - See below discussion on the `IHaloCallbacks` interface.

**IHaloCallbacks**

```
import za.co.synthesis.halo.sdk.model.IHaloCallbacks

public interface IHaloCallbacks {
    void onInitializationResult(HaloInitializationResult result);
    void onHaloUIMessage(HaloUIMessage message);
    void onHaloTransactionResult(HaloTransactionResult result);
    void onRequestJWT(Function1<? super String, Unit> function1);
    void onAttestationError(HaloAttesationHealthResult result);
    void onCameraControlLost();
}
```

The `IHaloCallbacks` interface encapsulates the call-back methods that the HaloSDK will use to asynchronously communicate back to the host application at relevant junctures:

1. Outcome of the initialization process (`onInitializationResult`)
2. Interim transaction progress (`onHaloUIMessage`)
3. Final outcome of a transaction (`onHaloTransactionResult`)
4. Issues with intermittent attestation checks (`onAttestationError`)

**HaloInitializationResult** 

```
import za.co.synthesis.halo.sdk.model.HaloInitializationResult

public class HaloInitializationResult {
    public HaloInitializationResultType resultType;
    public Currency terminalCurrency;
    public List<String> terminalLanguageCodes;
    public String terminalCountryCode;
    public String message;
}
```

Notes on `HaloInitializationResult`:

1.  `HaloInitializationResultType` 

    Here is a list of possible values for `HaloInitializationResultType` 

    Value | Meaning 
    -------|---------
    Initialized | Success
    AuthenticationError | Error occurred during authentication
    NetworkError | Network socket error during connection to server
    UnsupportedOperatingSystemVersion | Android OS too low
    RootedDevice | Device rooting detected
    InstrumentedDevice | Runtime instrumentation detected
    DebuggedDevice | Debug mode detected
    GeneralError | General failure
    RemoteAttestationFailure | Device failed remote leg of Android SafetyNet attestation
    NFCDisabledError | NFC either absent, turned off, or NFC permission not granted

2. Terminal Localisation Information Returned in `HaloInitializationResult`
    
    As part of initialization, the SDK will fetch its pre-defined terminal configuration from the Halo server - and this includes localisation data which should be checked bythe host application to ensure that the terminal is transacting in the expected currency, which is required for the limit checks done as part of kernel processing to be performed in the correct matching currency. In addition, these values should be used to determine the correct currency symbol and number of decimal points to use when displaying the transaction amount to the card-holder.

3. `terminalLanguageCodes`

    The EMV terminal specifi cation dictates that the terminal be confi gured with a list of language preferences (ISO 639-1 alpha2 language code), ordered from highestto lowest priority. The mobile app should ideally use this list to determine which language to use for display purposes.

4. `terminalCurrency`

    The terminal has a single supported currency. This is the currency in which card risk limits are configured, and the transaction must be conducted. It is also the currency that must be used when displaying amounts. The mobile app should determine the correct currency symbol, and number of decimal places from this. If this value is not as expected, then the mobile app should not allow transaction.

5. `terminalCountryCode`

    The terminal is configured with a country code that indicates the domestic country. The returned value is formatted as a ISO 3166-1 numeric 3 country code left padded with zeros to length 4, e.g. 0710 = South Africa.

## 7. Transaction Flow ##

This section describes the Transaction flow of the SDK in more detail.

**HaloSDK.startTransaction**

Once the SDK has been successfully initialized, as indicated by a `HaloInitializationResultType` of `Success`, a transaction may be initiated by calling `HaloSDK.startTransaction`.

```
public final fun startTransaction(
    transactionAmount: java.math.BigDecimal,
    merchantTransactionReference: kotlin.String
): za.co.synthesis.halo.sdk.model.HaloStartTransactionResult
```

Let's take a closer look at `startTransaction` parameters:

- `transactionAmount` - The purchase amount, stated in the `terminalCurrency` as returned in `HaloInitializationResult.terminalCurrency`.
- `merchantTransactionReference` - It is recommended to use a random GUID for this purpose.

The `merchantTransactionReference` is a unique-per-merchant transaction reference generated and supplied by the mobile application. Halo will generate and maintain its own internal ID for the transaction (`haloTransactionReference`), but from the perspective of the mobile application `merchantTransactionReference` together with the value of the
`Payment Processor Merchant-User ID` specified in the JWT `sub` field can be used to uniquely identify a merchant transaction.

This value needs to be unique per merchant transaction, i.e. different merchants could use the same `merchantTransactionReference` for two different transactions, but the value would need to unique per transaction for a given merchant. In the event that the same `merchantTransactionReference` is supplied for two different transactions for the same merchant, the second transaction will be rejected by the Halo server, and the final transaction result type returned for the second transaction will be `HaloTransactionResultType.DuplicateMerchantTransactionReferenceSupplied`.

In the event of the final transaction result type being `HaloTransactionResultType.Indeterminate` , then it is the `merchantTransactionReference` that should be used to lookup and potentially resolve the final transaction outcome - potentially through a manual reversal by the merchant via the web portal.

The return type of `startTransaction` is `HaloStartTransactionResult` and is defined as: 

```
import za.co.synthesis.halo.sdk.model.HaloTransactionResult
    public class HaloStartTransactionResult {
        public HaloStartTransactionResultType resultType;
        public String message;
    }
```

where `HaloStartTransactionResultType` is: 

```
import za.co.synthesis.halo.sdk.model.HaloTransactionResultType
    public enum HaloStartTransactionResultType {
        Started,
        NotInitialized,
        GeneralError,
        NFCDisabledError;
    }
```

**Start Transaction Flow**

As part of starting a transaction, the SDK will check:
- NFC is present and turned on
- SDK itself has been successfully initialized
- Platform runtime (root/debug/instrumentation)

`HaloSDK.startTransaction` will always synchronously return a `HaloStartTransactionResultType`, only a value of `Started`
indicates that the SDK is satisfied to actually start a new transaction, all other values indicate a failure of some kind.